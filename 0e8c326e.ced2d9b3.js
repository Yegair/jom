(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{62:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return s})),a.d(t,"toc",(function(){return p})),a.d(t,"default",(function(){return l}));var n=a(3),r=a(7),o=(a(0),a(86)),i={id:"parsers",title:"Parser Basics"},s={unversionedId:"getting-started/parsers",id:"getting-started/parsers",isDocsHomePage:!1,title:"Parser Basics",description:"A Parser is the basic building block of jom.",source:"@site/docs/getting-started/parsers.mdx",slug:"/getting-started/parsers",permalink:"/jom/docs/getting-started/parsers",editUrl:"https://github.com/Yegair/jom/edit/main/pages/docs/getting-started/parsers.mdx",version:"current",sidebar:"docs",previous:{title:"Installation",permalink:"/jom/docs/getting-started/"}},p=[{value:"Combinators",id:"combinators",children:[]},{value:"Input",id:"input",children:[]},{value:"ParseResult",id:"parseresult",children:[]},{value:"Custom Parsers",id:"custom-parsers",children:[]}],c={toc:p};function l(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parser"}),Object(o.b)("inlineCode",{parentName:"a"},"Parser"))," is the basic building block of ",Object(o.b)("em",{parentName:"p"},"jom"),".\nIt essentially is a function which consumes ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-input"}),Object(o.b)("inlineCode",{parentName:"a"},"Input")),",\nand returns a ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result"}),Object(o.b)("inlineCode",{parentName:"a"},"ParseResult")),".\nA ",Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," can be in one of two states, ",Object(o.b)("inlineCode",{parentName:"p"},"ok")," or ",Object(o.b)("inlineCode",{parentName:"p"},"not-ok")," (aka. ",Object(o.b)("inlineCode",{parentName:"p"},"error"),").\n",Object(o.b)("inlineCode",{parentName:"p"},"ok")," indicates that the parser was able to recognize the input and produced some\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/output.html"}),Object(o.b)("inlineCode",{parentName:"a"},"output")),".\n",Object(o.b)("inlineCode",{parentName:"p"},"not-ok")," indicates that the parser was unable to recognize the input and produced a\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-error"}),Object(o.b)("inlineCode",{parentName:"a"},"ParseError"))," instead.\nA ",Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," also contains the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/remaining.html"}),Object(o.b)("inlineCode",{parentName:"a"},"remaining"))," input,\nwhich is the input that has not be consumed by the parser."),Object(o.b)("p",null,"For example lets have a look at one of the most basic parsers\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers/alpha1.html"}),Object(o.b)("inlineCode",{parentName:"a"},"alpha1")),".\nIt parses one or more alphabetical characters,\nand is defined as ",Object(o.b)("inlineCode",{parentName:"p"},"Parser<String>")," which means that it will produce a ",Object(o.b)("inlineCode",{parentName:"p"},"String")," as its output."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'val parser = Parsers.alpha1()\n\nprintln(parser.parse("abc")) // prints Ok[abc]\nprintln(parser.parse("ab1")) // prints Ok[ab]\nprintln(parser.parse("123")) // prints Error[Alpha]\n')),Object(o.b)("p",null,"All predefined parsers are defined in ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers"}),Object(o.b)("inlineCode",{parentName:"a"},"Parsers")),".\nHave a look at the API docs to get an overview."),Object(o.b)("h2",{id:"combinators"},"Combinators"),Object(o.b)("p",null,"A ",Object(o.b)("inlineCode",{parentName:"p"},"Combinator")," is a higher-order ",Object(o.b)("inlineCode",{parentName:"p"},"Parser"),".\nIt ",Object(o.b)("em",{parentName:"p"},"combines")," other, so called ",Object(o.b)("em",{parentName:"p"},"embedded")," parsers, into a new parser.\nSince combinators are themselves parsers, they can also be embedded into other combinators.\nThis way the existing basic ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers"}),Object(o.b)("inlineCode",{parentName:"a"},"Parsers")),"\nand ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-combinators"}),Object(o.b)("inlineCode",{parentName:"a"},"Combinators"))," can be combined in any thinkable way,\nin order to create exactly the parser one needs."),Object(o.b)("p",null,"As an example lets have a look at ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-combinators/alt.html"}),Object(o.b)("inlineCode",{parentName:"a"},"alt")),",\nwhich is one of the most common and most powerful combinators.\nIt takes multiple embedded parsers and applies them in order until one of the parsers recognizes the input."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'val parser = Combinators.alt(\n  Parsers.alpha1(),\n  Parsers.digit1()\n)\n\nprintln(parser.parse("abc")) // prints Ok[abc]\nprintln(parser.parse("ab1")) // prints Ok[ab]\nprintln(parser.parse("123")) // prints Ok[123]\nprintln(parser.parse("12a")) // prints Ok[12]\nprintln(parser.parse("!12a")) // prints Error[Digit]\n')),Object(o.b)("p",null,"This works because ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers/alpha1.html"}),Object(o.b)("inlineCode",{parentName:"a"},"alpha1")),"\nand ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers/digit1.html"}),Object(o.b)("inlineCode",{parentName:"a"},"digit1"))," both produce ",Object(o.b)("inlineCode",{parentName:"p"},"String")," outputs.\nSo the resulting parser is also of type ",Object(o.b)("inlineCode",{parentName:"p"},"Parser<String>"),".\nBut what if we wanted to also parse the character ",Object(o.b)("inlineCode",{parentName:"p"},"'!'"),"?"),Object(o.b)("p",null,"A first attempt might look like this:"),Object(o.b)("div",{className:"admonition admonition-danger alert alert--danger"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"})))),"Compile Error")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("pre",{parentName:"div"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"val parser = Combinators.alt(\n  Parsers.alpha1(),\n  Parsers.digit1(),\n  Parsers.codePoint('!')\n)\n")))),Object(o.b)("p",null,"This won't compile,\nbecause ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers/code-point.html"}),Object(o.b)("inlineCode",{parentName:"a"},"codePoint"))," returns a Parser of type ",Object(o.b)("inlineCode",{parentName:"p"},"Parser<Utf8CodePoint>"),".\nHowever, we can use another combinator ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-combinators/map.html"}),Object(o.b)("inlineCode",{parentName:"a"},"map"))," to make this work."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'val parser = Combinators.alt(\n  Parsers.alpha1(),\n  Parsers.digit1(),\n  Combinators.map(Parsers.codePoint(\'!\')) { it.utf8() }\n)\n\nprintln(parser.parse("abc")) // prints Ok[abc]\nprintln(parser.parse("ab1")) // prints Ok[ab]\nprintln(parser.parse("123")) // prints Ok[123]\nprintln(parser.parse("12a")) // prints Ok[12]\nprintln(parser.parse("!1a")) // prints Ok[!]\n')),Object(o.b)("p",null,"All predefined combinators are defined in ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-combinators"}),Object(o.b)("inlineCode",{parentName:"a"},"Combinators")),".\nHave a look at the API docs to get an overview."),Object(o.b)("h2",{id:"input"},"Input"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-input"}),Object(o.b)("inlineCode",{parentName:"a"},"Input"))," is a simple abstraction over a stream of bytes.\nIt is the only parameter that is passed to a parser,\nso it's interface determines the overall capability of ",Object(o.b)("em",{parentName:"p"},"jom")," parsers."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Up to now we have only seen parsers being invoked with ",Object(o.b)("inlineCode",{parentName:"p"},"String")," parameters,\nso how can ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," be the only parameter for a ",Object(o.b)("inlineCode",{parentName:"p"},"Parser")," you might ask?\nActually an expression of the form"),Object(o.b)("pre",{parentName:"blockquote"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'parser.parse("foobar")\n')),Object(o.b)("p",{parentName:"blockquote"},"is just shorthand for"),Object(o.b)("pre",{parentName:"blockquote"},Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'parser.parse(Input.of("foobar"))\n'))),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Input")," instances can be created from various sources such as\n",Object(o.b)("inlineCode",{parentName:"p"},"String"),",\n",Object(o.b)("inlineCode",{parentName:"p"},"ByteArray")," (Java ",Object(o.b)("inlineCode",{parentName:"p"},"byte[]"),"),\n",Object(o.b)("inlineCode",{parentName:"p"},"java.io.InputStream"),",\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://square.github.io/okio/2.x/okio/okio/-source"}),Object(o.b)("inlineCode",{parentName:"a"},"okio.Source")),",\nand ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://square.github.io/okio/2.x/okio/okio/-byte-string"}),Object(o.b)("inlineCode",{parentName:"a"},"okio.ByteString")),".\nNo matter the source, creating an ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," always works the same,\nas an example let's parse the contents of a file using the classic Java Files API."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'Files.newInputStream(Paths.get("/path/to/my/file")).use { inputStream ->\n  val input = Input.of(inputStream)\n  val result = myParser.parse(input)\n\n  when {\n    result.ok -> result.output\n    else -> throw RuntimeException("could not parse $pathToMyFile")\n  }\n}\n')),Object(o.b)("p",null,"There is also an alternative way using ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://square.github.io/okio/"}),"Okio"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),'Paths.get("/path/to/my/file").source().use { source ->\n  val input = Input.of(source)\n  val result = myParser.parse(input)\n\n  when {\n    result.ok -> result.output\n    else -> throw RuntimeException("could not parse $pathToMyFile")\n  }\n}\n')),Object(o.b)("p",null,"Under the hood ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," makes heavy use of ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"https://square.github.io/okio/2.x/okio/okio/-buffered-source"}),Object(o.b)("inlineCode",{parentName:"a"},"okio.BufferedSource")),",\nso internally the ",Object(o.b)("inlineCode",{parentName:"p"},"java.io.InputStream")," would be wrapped by Okio anyway.\nHence, there is no real difference between the two approaches in terms of efficiency."),Object(o.b)("p",null,"The most important point of these examples is, that ",Object(o.b)("inlineCode",{parentName:"p"},"Input")," instances do not manage their underlying source.\nThus, the caller must care about closing the ",Object(o.b)("inlineCode",{parentName:"p"},"InputStream")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Source")," once the parser is done.\nAlso, the ",Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," of a parser holds a reference to the ",Object(o.b)("inlineCode",{parentName:"p"},"Input"),',\nso the result also becomes "invalid" when the underlying ',Object(o.b)("inlineCode",{parentName:"p"},"InputStream")," or ",Object(o.b)("inlineCode",{parentName:"p"},"Source")," is closed.\nIn this case for example the ",Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," itself should not be returned from the ",Object(o.b)("inlineCode",{parentName:"p"},"use")," block.\nHowever, the ",Object(o.b)("inlineCode",{parentName:"p"},"output")," of a ",Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," can safely be returned."),Object(o.b)("h2",{id:"parseresult"},"ParseResult"),Object(o.b)("p",null,Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result"}),Object(o.b)("inlineCode",{parentName:"a"},"ParseResult"))," is a simple wrapper for the result of a parser.\nIt's ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/ok.html"}),Object(o.b)("inlineCode",{parentName:"a"},"ok"))," property indicates whether a parser was\nsuccessful or has failed recognizing the input.\nIf ",Object(o.b)("inlineCode",{parentName:"p"},"ok")," is ",Object(o.b)("inlineCode",{parentName:"p"},"true")," the parser was successful, and the result of the parser can be obtained via the\n",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/output.html"}),Object(o.b)("inlineCode",{parentName:"a"},"output"))," property.\nOtherwise, the parser failed and trying to access the ",Object(o.b)("inlineCode",{parentName:"p"},"output")," property results in an ",Object(o.b)("inlineCode",{parentName:"p"},"IllegalStateException")," being\nthrown.\nIf the parser failed the ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/error.html"}),Object(o.b)("inlineCode",{parentName:"a"},"error"))," property holds the\nparse error which describes the cause of the failure.\nAccessing the ",Object(o.b)("inlineCode",{parentName:"p"},"error")," property on a successful parse result also causes an ",Object(o.b)("inlineCode",{parentName:"p"},"IllegalStateException")," being thrown."),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"The error reporting capabilities of ",Object(o.b)("em",{parentName:"p"},"jom")," are currently extremely limited.\nBetter error reporting will be implemented in a future version."))),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"ParseResult")," also provides some monadic methods for working with ",Object(o.b)("inlineCode",{parentName:"p"},"output")," and ",Object(o.b)("inlineCode",{parentName:"p"},"error"),",\nwithout having to check whether ",Object(o.b)("inlineCode",{parentName:"p"},"ok")," is ",Object(o.b)("inlineCode",{parentName:"p"},"true")," or ",Object(o.b)("inlineCode",{parentName:"p"},"false"),".\nFor example, it is possible to ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parse-result/map.html"}),Object(o.b)("inlineCode",{parentName:"a"},"map"))," the output value of\nsuccessful parse results:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"val result = myIntParser\n  .parse(input.peek())\n  // this mapping will be called when the parser succeeds\n  .map { remaining, output ->\n    when (output) {\n      // we can use map to change the result type (in this case to Boolean)\n      42 -> ParseResult.ok(remaining, true)\n      // we can also transform a successful parse result into an error\n      13 -> ParseResult.error(input, ParseError.Digit)\n      else -> ParseResult.ok(remaining, false)\n    }\n  }\n")),Object(o.b)("p",null,"It is also possible to map the error, however in that case we need to map successful outputs as well as errors,\nin order to keep our type-safety."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"val result = myIntParser\n  .parse(input.peek())\n  .map(\n    // this mapping will be called when the parser succeeds\n    ok = { remaining, output ->\n      when (output) {\n        13 -> ParseResult.error(input, ParseError.Digit)\n        else -> ParseResult.ok(remaining, output)\n      }\n    },\n    // this mapping will be called when the parser fails\n    error = { remaining, err ->\n      when (err) {\n          // we can transform a failed parse result into a success\n          ParseError.Eof -> ParseResult.ok(remaining, -1)\n          // we can also alter the error itself\n          else -> ParseResult.error(remaining, ParseError.Digit)\n      }\n    }\n  )\n")),Object(o.b)("h2",{id:"custom-parsers"},"Custom Parsers"),Object(o.b)("p",null,"Sometimes the predefined ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-parsers"}),Object(o.b)("inlineCode",{parentName:"a"},"Parsers")),"\nand ",Object(o.b)("a",Object(n.a)({parentName:"p"},{href:"/jom/api/jom/io.yegair.jom/-combinators"}),Object(o.b)("inlineCode",{parentName:"a"},"Combinators")),"\nmight not be enough to implement exactly the parser one needs.\nIn such hopefully rare cases it is possible to implement custom parsers from scratch.\nFor example lets assume we want write a custom parser which parses exactly one alphabetical letter."),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"val customParser = Parser { input ->\n\n  // we don't know whether the next codepoint is alphabetical,\n  // so we have to peek instead of just consuming it\n  val remaining = input.peek()\n\n  // consume the next UTF-8 codepoint from the peeking input\n  // this will leave the original input unchanged\n  val codePoint = remaining.readUtf8CodePoint()\n\n  when {\n    // check whether the parsed code point is the special EOF code point\n    // which indicates that the end of the given input has been reached\n    Input.isEof(codePoint) -> ParseResult.error(input, ParseError.Eof)\n    // if the codepoint is alphabetical\n    // return it together with the remaining input\n    codePoint.isAlpha() -> ParseResult.ok(remaining, codePoint)\n    // otherwise return the original input and an appropriate error\n    else -> ParseResult.error(input, ParseError.CodePoint)\n  }\n}\n")),Object(o.b)("p",null,"Of course, it is also possible to implement a parser in a more classical way:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"class CustomParser : Parser<Utf8CodePoint> {\n  override fun parse(input: Input): ParseResult<Utf8CodePoint> {\n    // the implementation is the same as above...\n  }\n}\n")),Object(o.b)("p",null,"Using ",Object(o.b)("inlineCode",{parentName:"p"},"class")," or ",Object(o.b)("inlineCode",{parentName:"p"},"object")," instead of ",Object(o.b)("inlineCode",{parentName:"p"},"val")," can help when there are multiple parsers,\nthat are circular dependent on each other,\nsince that is not possible with simple variables.\nIn such cases there is also the possibility to implement parsers as simple methods,\nif ",Object(o.b)("inlineCode",{parentName:"p"},"class")," or ",Object(o.b)("inlineCode",{parentName:"p"},"object")," per parser seems to verbose:"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-kotlin"}),"object MyParsers {\n\n  fun customParser1(input: Input): ParseResult<Utf8CodePoint> {\n    // the implementation is also the same as above...\n  }\n\n  fun customParser2(input: Input): ParseResult<Utf8CodePoint> {\n    // another implementation\n  }\n\n  fun customCombinator(input: Input): ParseResult<Utf8CodePoint> {\n    return Combinators.alt(\n      ::customParser1,\n      ::customParser2\n    ).parse(input)\n  }\n}\n")))}l.isMDXComponent=!0},86:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return j}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),l=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},b=function(e){var t=l(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),b=l(a),u=n,j=b["".concat(i,".").concat(u)]||b[u]||m[u]||o;return a?r.a.createElement(j,s(s({ref:t},c),{},{components:a})):r.a.createElement(j,s({ref:t},c))}));function j(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);